// GENERATED FILE - DO NOT EDIT.
// Generated by gen_mtl_internal_shaders.py
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//

// C++ string version of Metal default shaders for debug purpose.




constexpr char default_metallib_src[] = R"(
#include <metal_stdlib>
#include <simd/simd.h>
# 1 "master_source.metal"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 374 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "master_source.metal" 2








# 1 "./clear.metal" 1







# 1 "./common.h" 1
# 16 "./common.h"
using namespace metal;


constant float2 gCorners[6] = {
    float2(-1.0f, 1.0f), float2(1.0f, -1.0f), float2(-1.0f, -1.0f),
    float2(-1.0f, 1.0f), float2(1.0f, 1.0f), float2(1.0f, -1.0f),
};



constant int gTexcoordsIndices[6] = {2, 1, 0, 2, 3, 1};

fragment float4 dummyFS()
{
    return float4(0, 0, 0, 0);
}
# 9 "./clear.metal" 2

struct ClearParams
{
    float4 clearColor;
    float clearDepth;
};

vertex float4 clearVS(unsigned int vid [[ vertex_id ]],
                      constant ClearParams &clearParams [[buffer(0)]])
{
    return float4(gCorners[vid], clearParams.clearDepth, 1.0);
}

fragment float4 clearFS(constant ClearParams &clearParams [[buffer(0)]])
{
    return clearParams.clearColor;
}
# 10 "master_source.metal" 2
# 1 "./blit.metal" 1
# 11 "./blit.metal"
struct BlitParams
{

    float2 srcTexCoords[4];
    int srcLevel;
    bool srcLuminance;
    bool dstFlipY;
    bool dstLuminance;
};

struct BlitVSOut
{
    float4 position [[position]];
    float2 texCoords [[user(locn1)]];
};

vertex BlitVSOut blitVS(unsigned int vid [[ vertex_id ]],
                         constant BlitParams &options [[buffer(0)]])
{
    BlitVSOut output;
    output.position = float4(gCorners[vid], 0.0, 1.0);
    output.texCoords = options.srcTexCoords[gTexcoordsIndices[vid]];

    if (options.dstFlipY)
    {
        output.position = -output.position;
    }

    return output;
}

float4 blitSampleTexture(texture2d<float> srcTexture,
                     float2 texCoords,
                     constant BlitParams &options)
{
    constexpr sampler textureSampler(mag_filter::linear,
                                     min_filter::linear);
    float4 output = srcTexture.sample(textureSampler, texCoords, level(options.srcLevel));

    if (options.srcLuminance)
    {
        output.gb = float2(output.r, output.r);
    }

    return output;
}

float4 blitOutput(float4 color, constant BlitParams &options)
{
    float4 ret = color;

    if (options.dstLuminance)
    {
        ret.r = ret.g = ret.b = (color.r * 0.3) + (color.g * 0.59) + (color.b * 0.11);
    }

    return ret;
}

fragment float4 blitFS(BlitVSOut input [[stage_in]],
                       texture2d<float> srcTexture [[texture(0)]],
                       constant BlitParams &options [[buffer(0)]])
{
    return blitOutput(blitSampleTexture(srcTexture, input.texCoords, options), options);
}

fragment float4 blitPremultiplyAlphaFS(BlitVSOut input [[stage_in]],
                                       texture2d<float> srcTexture [[texture(0)]],
                                       constant BlitParams &options [[buffer(0)]])
{
    float4 output = blitSampleTexture(srcTexture, input.texCoords, options);
    output.xyz *= output.a;
    return blitOutput(output, options);
}

fragment float4 blitUnmultiplyAlphaFS(BlitVSOut input [[stage_in]],
                                      texture2d<float> srcTexture [[texture(0)]],
                                      constant BlitParams &options [[buffer(0)]])
{
    float4 output = blitSampleTexture(srcTexture, input.texCoords, options);
    if (output.a != 0.0)
    {
        output.xyz *= 1.0 / output.a;
    }
    return blitOutput(output, options);
}
# 11 "master_source.metal" 2
# 1 "./gen_indices.metal" 1








struct IndexConversionParams
{
    uint32_t srcOffset;
    uint32_t indexCount;
};







kernel void convertIndexU8ToU16(uint idx[[thread_position_in_grid]],
                                constant IndexConversionParams &options[[buffer(0)]],
                                constant uchar *input[[buffer(1)]],
                                device ushort *output[[buffer(2)]])
{
    if (idx >= options.indexCount) { return; };
    output[idx] = input[options.srcOffset + idx];
}

kernel void convertIndexU16Unaligned(uint idx[[thread_position_in_grid]],
                                     constant IndexConversionParams &options[[buffer(0)]],
                                     constant uchar *input[[buffer(1)]],
                                     device ushort *output[[buffer(2)]])
{
    if (idx >= options.indexCount) { return; };
    ushort inputLo = input[options.srcOffset + 2 * idx];
    ushort inputHi = input[options.srcOffset + 2 * idx + 1];

    ushort value = inputLo | (inputHi << 8);
    output[idx] = value;
}

kernel void convertIndexU16Aligned(uint idx[[thread_position_in_grid]],
                                   constant IndexConversionParams &options[[buffer(0)]],
                                   constant ushort *input[[buffer(1)]],
                                   device ushort *output[[buffer(2)]])
{
    if (idx >= options.indexCount) { return; };
    ushort value = input[options.srcOffset / 2 + idx];
    output[idx] = value;
}

kernel void convertIndexU32Unaligned(uint idx[[thread_position_in_grid]],
                                     constant IndexConversionParams &options[[buffer(0)]],
                                     constant uchar *input[[buffer(1)]],
                                     device uint *output[[buffer(2)]])
{
    if (idx >= options.indexCount) { return; };
    uint input0 = input[options.srcOffset + 4 * idx];
    uint input1 = input[options.srcOffset + 4 * idx + 1];
    uint input2 = input[options.srcOffset + 4 * idx + 2];
    uint input3 = input[options.srcOffset + 4 * idx + 3];

    uint value = input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
    output[idx] = value;
}

kernel void convertIndexU32Aligned(uint idx[[thread_position_in_grid]],
                                   constant IndexConversionParams &options[[buffer(0)]],
                                   constant uint *input[[buffer(1)]],
                                   device uint *output[[buffer(2)]])
{
    if (idx >= options.indexCount) { return; };
    uint value = input[options.srcOffset / 4 + idx];
    output[idx] = value;
}
# 12 "master_source.metal" 2

)";
